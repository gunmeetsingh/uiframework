# Metadata-Driven OAM Portal Architecture

## Executive Summary
The OAM Portal employs a highly scalable, **metadata-driven architecture**. This design allows for rapid deployment of new features (configurations, tables, charts) by simply defining JSON schemas, rather than writing custom code for every screen. This significantly reduces time-to-market and ensures absolute consistency across the application.

## High-Level Architecture Diagram (Mermaid)

```mermaid
graph TD
    %% Styling
    classDef meta fill:#22D3EE,stroke:#0F1729,stroke-width:2px,color:#0F1729;
    classDef core fill:#3C83F6,stroke:#0F1729,stroke-width:2px,color:#FFFFFF;
    classDef ui fill:#111827,stroke:#3C83F6,stroke-width:2px,color:#F8FAFC;

    subgraph "Metadata Logic (Define Once)"
        ConfigJSON[Config Schema.json<br/>(Fields, Types, Validations)]:::meta
        ReportJSON[Report Schema.json<br/>(Charts, Series, Axes)]:::meta
    end

    subgraph "Frontend Core (Next.js Application)"
        Theme[Theme Engine<br/>(Spartified Brand & Dark Mode)]:::core
        Auth[Security Layer<br/>(RBAC / Permissions)]:::core
        
        subgraph "Generic Rendering Engines"
            ConfigEngine[Config Engine<br/>(Auto-Generates Tables & Forms)]:::core
            ReportEngine[Report Engine<br/>(Auto-Generates KPI Charts)]:::core
            IntegrationEngine[Integration Engine<br/>(Grafana / External Tools)]:::core
        end
    end

    subgraph "User Interface (Render Everywhere)"
        UI_Config[Dynamic Configuration Pages<br/>(CRUD Operations)]:::ui
        UI_Report[Interactive Dashboards<br/>(Visual Analytics)]:::ui
        UI_Monitor[Monitoring Panels<br/>(Real-time Status)]:::ui
    end

    %% Flows
    ConfigJSON -->|Drives| ConfigEngine
    ReportJSON -->|Drives| ReportEngine
    
    Theme -->|Styles| ConfigEngine
    Theme -->|Styles| ReportEngine
    Auth -->|Secures| UI_Config
    Auth -->|Secures| UI_Monitor

    ConfigEngine -->|Renders| UI_Config
    ReportEngine -->|Renders| UI_Report
    IntegrationEngine -->|Embeds| UI_Monitor
```

## Key Components

### 1. Metadata Schema Layer (JSON)
*   **Purpose**: Acts as the "blueprint" for the application.
*   **Benefit**: Non-developers or business analysts can potentially define new screens just by configuring a JSON file.
*   **Example**: `node-config.json` defines that a "Node" has a name, IP address (text), and type (select).

### 2. Generic Engines (The "Brain")
*   **Config Engine**: A smart component that reads any `Config Schema` and automatically builds:
    *   A searchable **Data Table** with columns matching the schema.
    *   **Create/Edit Forms** with appropriate validation (e.g., date pickers for dates, dropdowns for selects).
    *   **CRUD Logic** (Create, Read, Update, Delete) without writing new React code.
*   **Report Engine**: Reads a `Report Schema` and dynamically renders complex charts using Apache ECharts, applying the correct theme automatically.

### 3. Core Services
*   **Theme Provider**: Centralized styling system (based on Ant Design `ConfigProvider`) that enforces the "Spartified" brand (colors, fonts, dark mode) globally.
*   **Auth Provider**: Manages user sessions and role-based access (e.g., showing "Monitor Platform" only to users with `grafana` permission).

### 4. External Integrations
*   **Grafana**: Seamlessly embedded monitoring dashboards that feel like a native part of the application due to iframe theme alignment.

## Benefits for Management
1.  **Speed**: New configuration screens can be added in minutes (just JSON), not days.
2.  **Consistency**: Because all screens are generated by the same engine, they look and behave exactly the same. UX bugs are fixed once for everyone.
3.  **Maintainability**: Codebase size is small. Logic is concentrated in the "Engines," not duplicated across 50 different pages.
4.  **Scalability**: The architecture creates a framework that can grow to hundreds of screens without becoming unmanageable.
